{"./":{"url":"./","title":"介绍","keywords":"","body":" 介绍 深入理解 React 16.8 之后提出的 Hooks 概念，理解新的 UI 设计模式。 © 2020 Elton all right reserved，powered by Gitbook该文件最后修改时间： 2020-08-01 09:45:18 "},"content/ch01.html":{"url":"content/ch01.html","title":"导言","keywords":"","body":" 先思考几个问题 什么是 UI UI 是否可以表示为 UI=f(data) UI = f(data)UI=f(data) 就是函数 fff 将（data）映射到用户界面（UI）上。 例如 [商品 1, 商品 2, 商品 3, 商品 4, 商品 5]数组数据 ⇒ \\Rightarrow⇒ 商品列表页面。 通过数据产生页面。 状态是不是数据 什么是状态（state） 状态含有一个隐含的意义，就是存在改变状态的行为（behavior），背后存在一个状态机。 例如点赞数（like）隐含了增加一个赞的行为（addLike） © 2020 Elton all right reserved，powered by Gitbook该文件最后修改时间： 2020-08-03 14:23:04 "},"content/ch02.html":{"url":"content/ch02.html","title":"Hooks 的基本概念","keywords":"","body":"彻底理解 React Hooks 是什么 如何描述 UI（User Interface） UI 的单向数据流，React 和 Vue 都使用这个模型。 可以把消息和重算抽象为行为 进一步把数据进行拆分，把不变的作为视图的属性，变的作为状态。 状态又映射了行为，因此行为可以封装在状态内。 让作用来监听一切 什么是 Hooks 重新定义 UI： v=f(props,state),UI=VuseHook1(),useHook2()... v = f(props, state), UI = V useHook1(), useHook2()...v=f(props,state),UI=VuseHook1(),useHook2()... 函数f(props,state)f(props, state)f(props,state)是根据属性和状态把界面画出来，而 hook 提供了相关界面的能力。比如点赞的场景，点赞的视图是由f(props,state)f(props, state)f(props,state)根据点赞数生成的视图，而点赞的 hook 提供了点赞的能力和点赞的状态。 Hook 是跟 UI 有关联的行为，有状态的行为，作用的行为，上下文的行为。 state hook effect hook context hook © 2020 Elton all right reserved，powered by Gitbook该文件最后修改时间： 2020-08-03 14:53:40 "},"content/ch03.html":{"url":"content/ch03.html","title":"Hooks 的基本用法","keywords":"","body":"Hooks API 状态(State) const [count, setCount] = useState(0) count表示状态，setCount表示行为， useStete是Hook React Hooks 帮助大家将数据和行为进行绑定。 例子： import React,{useState} from \"react\" export default () =>{ const [count, setCount] = useState(0); return ( Your count:{count}. setCount(count+1)}\">Add ); } export default导出一个匿名函数，是为了绘制视图用的。Hooks 把状态和行为跟这个视图绘制函数绑定，视图函数只需要关心界面的样子和在什么时候触发对应的行为而不用考虑视图中的状态和行为。 自定义 state hooks 也可以自定义一个 hooks，让代码看上去更加具有语义。 import React,{useState} from \"react\" function useCount(initialVaule) { const [count, setCount] = useState(initialValue); return [ count, () => { setCount(count+1); \\\\ 封装了动作的逻辑内容 } ]; } export default () =>{ const [count, addCount] = useCount(0); return ( Your count:{count}. addCount()}\">Add ); } 定义了一个 useCount 的自定义 hook，把行为封装到返回的函数里面了。视图渲染函数只要知道什么时候触发什么事件就可以了。不需要关心行为的具体逻辑内容。真正做到了视图和业务逻辑脱钩。UI 只是一个渲染函数。 作用(effect) 存在 UI 渲染函数将数据映射到视图之外的内容，称之为作用，是在视图中看不到的内容。 例如：console.log()，URL 跳转、Cookie 等。 例子： import React,{useState} from \"react\" export default () =>{ const [count, setCount] = useState(0); useEffect(()=>{ console.log(\"You clicked count {count} times.\"); }) return ( Your count:{count}. setCount(count+1)}\">Add ); } useEffect会在每次视图渲染的时候被调用。如果加入第二个参数（是个数组），则表示是依赖于某个事物变化的作用。 useEffect(()=>{ console.log(\"You clicked count {count} times.\") },[count]) 这个就表示依赖于count的作用，每次 count 改变的时候，这个 useEffect 就会比调用。 如果第二个参数是一个空数组[]，就表示依赖于空的变化的作用。而空是不会变的，所以这个 useEffect 只会被执行一次。 useEffect(()=>{ console.log(\"You clicked count {count} times.\") },[]) 第二个参数里面如果是一个常数，其实跟一个空数组作用是一样的，常数是不变的，所以这个useEffect也只会执行一次。 自定义一个 effect hooks import React,{useState} from \"react\" function useInterval(callback, time) { useEffect(()=>{ const I = setInterval(callback,time); return () => { clearInterval(I); }; },[]); } export default () =>{ const [count, setCount] = useState(0); useInterval(()=>{ setCount(count+1); },1000); return ( Your count:{count}. setCount(count+1)}\">Add ); } useInterval 函数封装了一个 effect，传入一个callback函数和一个时间time。在time后执行callback函数。 useEffect函数的return语句是在组建销毁的时候去执行，释放对应的资源setInterval。 这里面有一个问题，执行上面的程序会发现，好像计时器没有起作用，count 的值一直显示是 1。这是因为我们的 effect 函数依赖的是一个空[]，所以只有在组建第一次渲染的时候被调用，而传入到setInterval中的 callback 函数永远是第一版本的那个函数，而 count 值也是初始值为 0 的那个 count。其实定时器是在执行的，只是每次定时器执行的时候，都是使用的第一次传入的 callback 函数和 count 值。 要想 count 被累计，应该这样调用： useInterval(()=>{ setCount(count=>count+1); },1000); 把 setCount 函数中传入一个函数，这样 React 就会帮助取原来的值并不断累加。 © 2020 Elton all right reserved，powered by Gitbook该文件最后修改时间： 2020-08-04 10:35:15 "},"content/ch04.html":{"url":"content/ch04.html","title":"Hooks 的 context","keywords":"","body":" 上下文(Context) 上下文就是你理解事物需要的背景知识。比如用户、环境等。 例子： import React, {useContext, useState} from \"react\"; const themes ={ light:{ foreground:\"#000000\"; background:\"#eeeeee\"; }, dark:{ foreground:\"#ffffff\"; background:\"#222222\"; } }; const ThemeContext = React.createContext({ theme:themes.light, toggle:()=>{} }) const ToolBar = () => { return } const ThemedButton = () => { const context = useContext(ThemeContext); return { context.toggle(); }} > Click me! } export default () => { return { setTheme(theme => { setTheme(theme === themes.light? themes.dark); }) } }}> ; }; © 2020 Elton all right reserved，powered by Gitbook该文件最后修改时间： 2020-08-04 11:07:31 "},"content/ch05.html":{"url":"content/ch05.html","title":"Reducer 的作用和使用场景","keywords":"","body":" Reducer 的作用和使用场景 reducer 提供一种抽象状态行为的通用封装（action）和计算过程的抽象封装（reducer） 视图会产生一些 action，然后 reducer 会根据行为来处理数据，再改变对应的状态，最后根据状态驱动视图渲染。 import React from \"react\"; function reducer(state, action){ console.log(state, action); switch(action.type){ case \"add\": return state+1; case \"sub\": return state-1; default: throw err; } } export default function Counter() { const [counter, dispatch] = useReducer(reducer, 0); return ( Your counter is : {counter} dispatch({type:\"add\"})}> + dispatch({type:\"sub\"})}> - ) } © 2020 Elton all right reserved，powered by Gitbook该文件最后修改时间： 2020-08-04 15:56:23 "},"content/ch06.html":{"url":"content/ch06.html","title":"引用(ref)","keywords":"","body":"引用(ref) 引用是管理 React 以外的对象。比如说输入框，媒体播放等组件。应用通常搭配 useEffect 一起使用。 import React,{useRef} from \"react\"; export default function UseRefExample(){ const refInput=useRef(); return ( { refInput.current.focus(); }}>Focus ) } ref 还有另外一个做用就是保存一个值。 import React,{useRef, useState} from \"react\"; export default function UseRefExample(){ const [counter, setCounter] = useState(0); const pref = useRef(null); return ( 当前值：{counter} 之前的值：{prev.current} { prev.current = counter; setCounter(x=>x+1); }}>Click me to add { prev.current = counter; setCounter(x=>x-1); }}>Click me to remove ) } © 2020 Elton all right reserved，powered by Gitbook该文件最后修改时间： 2020-08-04 17:21:37 "},"content/ch07.html":{"url":"content/ch07.html","title":"React Hooks 中的缓存设计","keywords":"","body":" React Hooks 中的缓存设计 React 中提供两种缓存机制： 缓存一个函数(useCallback) 缓存一个值(useMemo) 其实他们的作用是一样的。 import React, {useState, useMemo} from \"react\"; const UseMemoExample = () => { const [count, setCount] = useState(0); const memorizaedText = useMemo(() => { console.log(\"run useMemo function\"); return `this is a memorized text ${Date.now()}`; },[]); return( {memorizedText} You clicked {count} times. {setCount(count+1)}}>Click me ); }; export default UseMemoExample; 这里通过 useMemo 缓存了进入这个组件的时间(Date.now())。 © 2020 Elton all right reserved，powered by Gitbook该文件最后修改时间： 2020-08-04 17:34:24 "},"content/ch08.html":{"url":"content/ch08.html","title":"React Hooks 避坑指南和使用建议","keywords":"","body":" React Hooks 避坑指南和使用建议 使用 React memo 减少重绘次数 hooks 的同步问题 import React, {useState, useEffect} from \"react\"; export default() => { const[count, setCount]=useState(0); useEffect(()=>{ setInterval(() =>{ console.log(count); setCount(x=>x+1); },1000); },[]); return count; }; useEffect 因为仅仅依赖于空[]，所以useEffect中的内联函数只被使用了一次。所以里面的 count 值永远都是第一次赋值时候的那个值。因此在控制台永远输出 0。所以在 setCount 中使用了函数的形式来不断的更新当前的值。 应该构造自己的 hooks 封装行为 import React, {useState, useEffect} from \"react\"; function sleep(){ return new Promise((resolve) =>{ setTimeout(()=>{ resolve() },time); }) } async function getPerson(){ await sleep(200); return [\"a\",\"b\",\"c\"]; } async function usePerson(){ const [list, setList] = useState(null); function requst(){ const list = await getPerson(); setList(list); } useEffect(requst,[]); return list } export default () =>{ const list = usePerson(); if(list === null){ return Loading... } return ( {list.map((name,i) => { return name })} ); }; 视图中只有状态和触发状态改变的事件，其他都封装到 hooks 里面去。 每种行为作为一个 hook 不要把不相关的行为封装到一个 hook 行为中。每个 hook 应该是一个行为或者一种行为。 不要在思考生命周期了 始终用下面的方式来思考前端。就是一个视图函数基于属性和状态来生成视图，同时应用了很多 hooks 的作用。 v=f(props,state),useEffect,useState,useContext,use... v = f(props, state), useEffect, useState, useContext, use... v=f(props,state),useEffect,useState,useContext,use... © 2020 Elton all right reserved，powered by Gitbook该文件最后修改时间： 2020-08-04 18:16:25 "}}